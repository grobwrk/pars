<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN>
             <html>
             <head>
                <title>Coverage - out/build/linux-debug-llvm/test/test-events-network - [...]/lib/include/pars/net/op.h</title>
                <link rel="stylesheet" type="text/css" href="llvmcov2html.css"/>
             </head>
             <body>
             <table width="100%" border="0" cellspacing="0" cellpadding="0">
             <tr><td class="title">Coverage Report</td></tr>
             <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
             <tr>
             <td width="100%">
                <table cellpadding="1" border="0" width="100%">
                   <tr>
                      <td class="headerItem" width="20%">Command:</td>
                      <td class="headerValue" width="80%" colspan=6>out/build/linux-debug-llvm/test/test-events-network</td>
        </tr>
                     <tr>
                     <td class="headerItem" width="20%">Date:</td>
                     <td class="headerValue" width="15%">Wed Apr 23 13:58:28 2025 </td>
                     <td width="5%"></td>
                     <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
                     <td class="headerValue" width="10%">68</td>
                   </tr>
                   <tr>
                   <td class="headerItem" width="20%">Code&nbsp;covered:
                   <td class="headerValue" width="15%">0.0 %</td>
                   <td width="5%"></td>
                     <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
                     <td class="headerValue" width="10%">0</td>
                   </tr>
                 </table>
               </td>
             </tr>
             <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
           </table>
<pre class="source">
             : /*
             : Copyright (c) 2025 Giuseppe Roberti.
             : All rights reserved.
             : 
             : Redistribution and use in source and binary forms, with or without modification,
             : are permitted provided that the following conditions are met:
             : 
             : 1. Redistributions of source code must retain the above copyright notice, this
             : list of conditions and the following disclaimer.
             : 
             : 2. Redistributions in binary form must reproduce the above copyright notice,
             : this list of conditions and the following disclaimer in the documentation and/or
             : other materials provided with the distribution.
             : 
             : 3. Neither the name of the copyright holder nor the names of its contributors
             : may be used to endorse or promote products derived from this software without
             : specific prior written permission.
             : 
             : THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
             : ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             : WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
             : DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
             : ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             : (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             : LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
             : ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             : (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             : SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
             : */
             : #pragma once
             : 
             : #include &quot;pars/err.h&quot;
             : #include &quot;pars/ev/enqueuer.h&quot;
             : #include &quot;pars/ev/event.h&quot;
             : #include &quot;pars/ev/serializer.h&quot;
             : #include &quot;pars/fmt/helpers.h&quot;
             : #include &quot;pars/net/dir.h&quot;
             : 
             : #include &lt;nngpp/aio.h&gt;
             : #include &lt;nngpp/ctx_view.h&gt;
             : #include &lt;nngpp/pipe_view.h&gt;
             : #include &lt;nngpp/socket_view.h&gt;
             : #include &lt;spdlog/spdlog.h&gt;
             : 
             : #include &lt;functional&gt;
             : 
             : namespace nng
             : {
             : 
             : using cb_f = std::function&lt;void(nng::error, nng::msg)&gt;;
             : 
             : } // namespace nng
             : 
             : namespace pars::net
             : {
             : 
             : class op
             : {
             : public:
             :   ~op()
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    if (aio_m)</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      aio_m.wait();</span>
             :   }
             : 
<span class="lineNoCov">      0 / 1 </span> :   explicit operator bool() <span class="lineNoCov">{ return static_cast&lt;bool&gt;(aio_m); }</span>
             : 
             :   template&lt;ev::event_c event_t, tool_c tool_t&gt;
             :   void send(ev::enqueuer&amp; r, tool_t&amp; t, pipe p, event_t ev)
             :   {
             :     nng::msg m = ev::serialize::to_network(ev);
             : 
             :     if (p)
             :       m.set_pipe(p);
             : 
             :     pars::debug(SL, lf::net, &quot;{}: Send Message [{}]!&quot;, f::pntl{p, t}, m);
             : 
             :     // replace the operation with the new one
             :     cb_m = [&amp;, p, ev = std::move(ev)](nng::error ec, nng::msg m) mutable {
             :       if (ec == nng::error::success)
             :       {
             :         // NOTE: m is empty on success
             :         
             :         pars::debug(SL, lf::net, &quot;{}: Sent Event [{}]!&quot;, f::pntl{p, t}, ev);
             : 
             :         r.queue_sent(std::move(ev), t.socket_id(), t, p);
             :       }
             :       else
             :       {
             :         // NOTE: m is not empty on failure
             : 
             :         auto pv = m.get_pipe();
             : 
             :         pars::err(SL, lf::net, &quot;{}: Error Sending {}! [msg:{},err:{}]&quot;,
             :                   f::pntl{pv, t}, nametype(ev), m, ec);
             : 
             :         r.queue_fire(ev::network_error{ec, dir::out}, t.socket_id(), t, pv);
             :       }
             :     };
             : 
             :     // make aio - NOTE: pass this, cant move op
             :     aio_m = nng::make_aio(op::send_cb, this);
             : 
             :     // start send
             :     aio_m.set_msg(std::move(m));
             :     t.send_aio(aio_m);
             :   }
             : 
             :   template&lt;tool_c tool_t&gt;
             :   void recv(ev::enqueuer&amp; r, tool_t&amp; t)
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    pars::debug(SL, lf::net, &quot;{}: Receive Message!&quot;, f::pntl{{}, t});</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // replace the operation with the new one</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    cb_m = [&amp;](nng::error ec, nng::msg m) {</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      if (ec == nng::error::success)</span>
             :       {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        // NOTE: m is not empty on success</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        auto pv = m.get_pipe();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        pars::debug(SL, lf::net, &quot;{}: Received Message! [{}]&quot;, f::pntl{pv, t},</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">                    m);</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        r.queue_received(std::move(m), t.socket_id(), t, pv);</span>
             :       }
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      else</span>
             :       {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        // NOTE: m is empty on failure</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        auto pv = nng::pipe_view();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        pars::err(SL, lf::net, &quot;{}: Error Receiving! [{}]&quot;, f::pntl{pv, t}, ec);</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        r.queue_fire(ev::network_error{ec, dir::in}, t.socket_id(), t, pv);</span>
             :       }
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    };</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // make aio - NOTE: pass this, cant move op</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    aio_m = nng::make_aio(op::recv_cb, this);</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // start recv</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    t.recv_aio(aio_m);</span>
             :   }
             : 
             :   void sleep(nng_duration ms, std::function&lt;void()&gt; f)
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    cb_m = [&amp;, f](nng::error e, nng::msg m) {</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      if (e == nng::error::success)</span>
             :       {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        // the sleep completed successfully, execute f</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        f();</span>
             :       }
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    };</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // make aio - NOTE: pass this, cant move op</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    aio_m = nng::make_aio(op::sleep_cb, this);</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    nng::sleep(ms, aio_m);</span>
             :   }
             : 
             :   void reset_sleep(nng_duration ms)
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    stop();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // make aio - NOTE: pass this, cant move op</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    aio_m = nng::make_aio(op::sleep_cb, this);</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    nng::sleep(ms, aio_m);</span>
             :   }
             : 
             :   /**
             :    * @brief return result of asynchronous operation
             :    * @return
             :    *
             :    * The nng_aio_result() returns the result of the operation associated with
             :    * the handle aio. If the operation was successful, then 0 is returned.
             :    * Otherwise a non-zero error code is returned.
             :    */
<span class="lineNoCov">      0 / 1 </span> :   nng::error result() const <span class="lineNoCov">{ return aio_m.result(); }</span>
             : 
             :   /**
             :    * @brief abort asynchronous I/O operation
             :    * @param err
             :    *
             :    * The abort() function aborts an operation previously started with the handle
             :    * aio.
             :    *
             :    * If the operation is aborted, then the callback for the handle will be
             :    * called, and the function result() will return the error err.
             :    */
<span class="lineNoCov">      0 / 1 </span> :   void abort(nng::error err) const <span class="lineNoCov">{ aio_m.abort(static_cast&lt;int&gt;(err)); }</span>
             : 
             :   /**
             :    * @brief cancel asynchronous I/O operation
             :    *
             :    * The nng_aio_cancel() function aborts an operation previously started with
             :    * the handle aio. If the operation is aborted, then the callback for the
             :    * handle will be called, and the function nng_aio_result() will return the
             :    * error NNG_ECANCELED.
             :    *
             :    * This function does not wait for the operation to be fully aborted, but
             :    * returns immediately.
             :    *
             :    * If no operation is currently in progress (either because it has already
             :    * finished, or no operation has been started yet), then this function has no
             :    * effect.
             :    *
             :    * Same as abort(nng::error::canceled)
             :    */
<span class="lineNoCov">      0 / 1 </span> :   void cancel() const <span class="lineNoCov">{ aio_m.cancel(); }</span>
             : 
             :   /**
             :    * @brief wait for asynchronous I/O operation
             :    *
             :    * The nng_aio_wait() function waits for an asynchronous I/O operation to
             :    * complete. If the operation has not been started, or has already completed,
             :    * then it returns immediately.
             :    */
<span class="lineNoCov">      0 / 1 </span> :   void wait() const <span class="lineNoCov">{ aio_m.wait(); }</span>
             : 
             :   /**
             :    * @brief stop asynchronous I/O operation
             :    *
             :    * The stop() function stops the asynchronous I/O operation associated with
             :    * aio by aborting with NNG_ECANCELED, and then waits for it to complete or to
             :    * be completely aborted, and for the callback associated with the aio to have
             :    * completed executing.
             :    *
             :    * Same as cancel() + wait().
             :    */
<span class="lineNoCov">      0 / 1 </span> :   void stop() <span class="lineNoCov">{ aio_m.stop(); }</span>
             : 
             : private:
             :   static void send_cb(void* arg)
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    auto self = static_cast&lt;op*&gt;(arg);</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // get the result</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    auto res = self-&gt;aio_m.result();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    nng::msg msg;</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    if (res != nng::error::success)</span>
             :     {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      // take ownership of the message</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      msg = self-&gt;aio_m.release_msg();</span>
             :     }
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // execute the callback passing ownership of the message</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    self-&gt;cb_m(res, std::move((msg)));</span>
             :   }
             : 
             :   static void recv_cb(void* arg)
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    auto self = static_cast&lt;op*&gt;(arg);</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // get the result</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    auto res = self-&gt;aio_m.result();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    nng::msg msg;</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    if (res == nng::error::success)</span>
             :     {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      // take ownership of the message</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      msg = self-&gt;aio_m.release_msg();</span>
             :     }
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // execute the callback passing ownership of the message</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    /*</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    we're going to pass here a view of the msg so that the receiving handler</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    will be able to serialize it into an event.</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    */</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    self-&gt;cb_m(res, std::move((msg)));</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    /*</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    now that the msg was used, we can get rid of it</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    */</span>
             :   }
             : 
             :   static void sleep_cb(void* arg)
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    auto self = static_cast&lt;op*&gt;(arg);</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    auto res = self-&gt;aio_m.result();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    if (res == nng::error::success)</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      self-&gt;cb_m(res, nng::msg{});</span>
             :   }
             : 
             :   nng::aio aio_m;
             :   nng::cb_f cb_m;
             : };
             : 
             : } // namespace pars::net
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
             <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
             <tr><td class="versionInfo">Generated by: llvmcov2html</td></tr>
           </table>
           <br/>
           </body>
           </html>
