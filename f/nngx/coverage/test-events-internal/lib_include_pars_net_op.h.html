<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN>
             <html>
             <head>
                <title>Coverage - out/build/linux-debug-llvm/test/test-events-internal - [...]/lib/include/pars/net/op.h</title>
                <link rel="stylesheet" type="text/css" href="llvmcov2html.css"/>
             </head>
             <body>
             <table width="100%" border="0" cellspacing="0" cellpadding="0">
             <tr><td class="title">Coverage Report</td></tr>
             <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
             <tr>
             <td width="100%">
                <table cellpadding="1" border="0" width="100%">
                   <tr>
                      <td class="headerItem" width="20%">Command:</td>
                      <td class="headerValue" width="80%" colspan=6>out/build/linux-debug-llvm/test/test-events-internal</td>
        </tr>
                     <tr>
                     <td class="headerItem" width="20%">Date:</td>
                     <td class="headerValue" width="15%">Tue May 27 07:59:31 2025 </td>
                     <td width="5%"></td>
                     <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
                     <td class="headerValue" width="10%">62</td>
                   </tr>
                   <tr>
                   <td class="headerItem" width="20%">Code&nbsp;covered:
                   <td class="headerValue" width="15%">0.0 %</td>
                   <td width="5%"></td>
                     <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
                     <td class="headerValue" width="10%">0</td>
                   </tr>
                 </table>
               </td>
             </tr>
             <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
           </table>
<pre class="source">
             : /*
             : Copyright (c) 2025 Giuseppe Roberti.
             : All rights reserved.
             : 
             : Redistribution and use in source and binary forms, with or without modification,
             : are permitted provided that the following conditions are met:
             : 
             : 1. Redistributions of source code must retain the above copyright notice, this
             : list of conditions and the following disclaimer.
             : 
             : 2. Redistributions in binary form must reproduce the above copyright notice,
             : this list of conditions and the following disclaimer in the documentation and/or
             : other materials provided with the distribution.
             : 
             : 3. Neither the name of the copyright holder nor the names of its contributors
             : may be used to endorse or promote products derived from this software without
             : specific prior written permission.
             : 
             : THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
             : ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             : WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
             : DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
             : ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             : (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             : LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
             : ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             : (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             : SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
             : */
             : #pragma once
             : 
             : #include &quot;nngxx/aio.h&quot;
             : #include &quot;nngxx/err.h&quot;
             : #include &quot;nngxx/msg.h&quot;
             : #include &quot;nngxx/pipe.h&quot;
             : 
             : #include &quot;pars/ev/enqueuer.h&quot;
             : #include &quot;pars/ev/event.h&quot;
             : #include &quot;pars/ev/serializer.h&quot;
             : #include &quot;pars/fmt/helpers.h&quot;
             : #include &quot;pars/net/dir.h&quot;
             : 
             : #include &lt;spdlog/spdlog.h&gt;
             : 
             : #include &lt;expected&gt;
             : #include &lt;functional&gt;
             : 
             : namespace pars::net
             : {
             : 
             : using cb_f = std::function&lt;void(clev::expected&lt;void&gt;, nngxx::msg)&gt;;
             : 
             : class op
             : {
             : public:
             :   ~op()
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    if (aio_m)</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      aio_m.wait();</span>
             :   }
             : 
<span class="lineNoCov">      0 / 1 </span> :   explicit operator bool() <span class="lineNoCov">{ return static_cast&lt;bool&gt;(aio_m); }</span>
             : 
             :   template&lt;ev::event_c event_t, tool_c tool_t&gt;
             :   clev::expected&lt;void&gt; send(ev::enqueuer&amp; r, tool_t&amp; t, pipe p, event_t ev)
             :   {
             :     auto m = ev::serialize::to_network(ev);
             : 
             :     if (p)
             :       m.set_pipe(p);
             : 
             :     pars::debug(SL, lf::net, &quot;{}: Send Message [{}]!&quot;, f::pntl{p, t}, m);
             : 
             :     // replace the callback with the new one
             :     cb_m = [&amp;, p, ev = std::move(ev)](clev::expected&lt;void&gt; res,
             :                                       nngxx::msg m) mutable {
             :       if (res)
             :       {
             :         // NOTE: m is empty on success
             : 
             :         pars::debug(SL, lf::net, &quot;{}: Sent Event [{}]!&quot;, f::pntl{p, t}, ev);
             : 
             :         r.queue_sent(std::move(ev), t.socket_id(), t, p);
             :       }
             :       else
             :       {
             :         // NOTE: m is not empty on failure
             : 
             :         auto pv = m.get_pipe();
             : 
             :         pars::err(SL, lf::net, &quot;{}: Error Sending {}! [msg:{},err:{}]&quot;,
             :                   f::pntl{pv, t}, nametype(ev), m, res.error());
             : 
             :         r.queue_fire(ev::network_error{res.error(), dir::out}, t.socket_id(), t,
             :                      pv);
             :       }
             :     };
             : 
             :     return nngxx::make_aio(op::send_cb, this, std::move(m))
             :       .and_assign_to(aio_m)
             :       .and_then([&amp;](auto aio) {
             :         t.send_aio(aio);
             : 
             :         return clev::expected&lt;void&gt;{};
             :       });
             :   }
             : 
             :   template&lt;tool_c tool_t&gt;
             :   void recv(ev::enqueuer&amp; r, tool_t&amp; t)
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    pars::debug(SL, lf::net, &quot;{}: Receive Message!&quot;, f::pntl{{}, t});</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // replace the operation with the new one</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    cb_m = [&amp;](clev::expected&lt;void&gt; res, nngxx::msg m) {</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      if (res)</span>
             :       {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        // NOTE: m is not empty on success</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        auto pv = m.get_pipe();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        pars::debug(SL, lf::net, &quot;{}: Received Message! [{}]&quot;, f::pntl{pv, t},</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">                    m);</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        r.queue_received(std::move(m), t.socket_id(), t, pv);</span>
             :       }
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      else</span>
             :       {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        // NOTE: m is empty on failure</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        auto pv = nngxx::pipe_view();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        pars::err(SL, lf::net, &quot;{}: Error Receiving! [{}]&quot;, f::pntl{pv, t},</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">                  res.error());</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        r.queue_fire(ev::network_error{res.error(), dir::in}, t.socket_id(), t,</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">                     pv);</span>
             :       }
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    };</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // make aio - NOTE: pass this, cant move op</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    aio_m = nngxx::make_aio(op::send_cb, this).value_or_abort();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // start recv</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    t.recv_aio(aio_m);</span>
             :   }
             : 
             :   void sleep(nng_duration ms, std::function&lt;void()&gt; f)
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    cb_m = [&amp;, f](clev::expected&lt;void&gt; res, nngxx::msg m) {</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      if (res)</span>
             :       {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        // the sleep completed successfully, execute f</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">        f();</span>
             :       }
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    };</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // make aio - NOTE: pass this, cant move op</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    aio_m = nngxx::make_aio(op::send_cb, this).value_or_abort();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    nngxx::sleep(ms, aio_m);</span>
             :   }
             : 
             :   void reset_sleep(nng_duration ms)
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    stop();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // make aio - NOTE: pass this, cant move op</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    aio_m = nngxx::make_aio(op::send_cb, this).value_or_abort();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    nngxx::sleep(ms, aio_m);</span>
             :   }
             : 
             :   /**
             :    * @brief return result of asynchronous operation
             :    * @return
             :    *
             :    * The nng_aio_result() returns the result of the operation associated with
             :    * the handle aio. If the operation was successful, then 0 is returned.
             :    * Otherwise a non-zero error code is returned.
             :    */
             :   std::error_code result() const
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    return aio_m.result().error_or(nngxx::err::success);</span>
             :   }
             : 
             :   /**
             :    * @brief abort asynchronous I/O operation
             :    * @param err
             :    *
             :    * The abort() function aborts an operation previously started with the handle
             :    * aio.
             :    *
             :    * If the operation is aborted, then the callback for the handle will be
             :    * called, and the function result() will return the error err.
             :    */
<span class="lineNoCov">      0 / 1 </span> :   void abort(nngxx::err err) <span class="lineNoCov">{ aio_m.abort(err); }</span>
             : 
             :   /**
             :    * @brief cancel asynchronous I/O operation
             :    *
             :    * The nng_aio_cancel() function aborts an operation previously started with
             :    * the handle aio. If the operation is aborted, then the callback for the
             :    * handle will be called, and the function nng_aio_result() will return the
             :    * error NNG_ECANCELED.
             :    *
             :    * This function does not wait for the operation to be fully aborted, but
             :    * returns immediately.
             :    *
             :    * If no operation is currently in progress (either because it has already
             :    * finished, or no operation has been started yet), then this function has no
             :    * effect.
             :    *
             :    * Same as abort(nngxx::error::canceled)
             :    */
<span class="lineNoCov">      0 / 1 </span> :   void cancel() <span class="lineNoCov">{ aio_m.cancel(); }</span>
             : 
             :   /**
             :    * @brief wait for asynchronous I/O operation
             :    *
             :    * The nng_aio_wait() function waits for an asynchronous I/O operation to
             :    * complete. If the operation has not been started, or has already completed,
             :    * then it returns immediately.
             :    */
<span class="lineNoCov">      0 / 1 </span> :   void wait() const <span class="lineNoCov">{ aio_m.wait(); }</span>
             : 
             :   /**
             :    * @brief stop asynchronous I/O operation
             :    *
             :    * The stop() function stops the asynchronous I/O operation associated with
             :    * aio by aborting with NNG_ECANCELED, and then waits for it to complete or to
             :    * be completely aborted, and for the callback associated with the aio to have
             :    * completed executing.
             :    *
             :    * Same as cancel() + wait().
             :    */
<span class="lineNoCov">      0 / 1 </span> :   void stop() <span class="lineNoCov">{ aio_m.stop(); }</span>
             : 
             : private:
             :   static void send_cb(void* arg)
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    auto self = static_cast&lt;op*&gt;(arg);</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // get the result</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    auto res = self-&gt;aio_m.result();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    nngxx::msg msg;</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    if (res)</span>
             :     {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      // take ownership of the message</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      msg = self-&gt;aio_m.release_msg();</span>
             :     }
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // execute the callback passing ownership of the message</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    self-&gt;cb_m(res, std::move(msg));</span>
             :   }
             : 
             :   static void recv_cb(void* arg)
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    auto self = static_cast&lt;op*&gt;(arg);</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // get the result</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    auto res = self-&gt;aio_m.result();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    nngxx::msg msg;</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    if (res)</span>
             :     {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      // take ownership of the message</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">      msg = self-&gt;aio_m.release_msg();</span>
             :     }
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    // execute the callback passing ownership of the message</span>
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    self-&gt;cb_m(res, std::move(msg));</span>
             :   }
             : 
             :   static void sleep_cb(void* arg)
             :   {
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    auto self = static_cast&lt;op*&gt;(arg);</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    auto ok = self-&gt;aio_m.result();</span>
             : 
<span class="lineNoCov">      0 / 1 </span> : <span class="lineNoCov">    self-&gt;cb_m(ok, nngxx::msg{});</span>
             :   }
             : 
             :   nngxx::aio aio_m;
             :   cb_f cb_m;
             : };
             : 
             : } // namespace pars::net
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
             <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
             <tr><td class="versionInfo">Generated by: llvmcov2html</td></tr>
           </table>
           <br/>
           </body>
           </html>
